任务：阅读进度功能
流程：
当我点击图书详情，进入阅读区开始阅读，系统会记录我当前阅读到了哪里，当我阅读了一部分之后返回图书馆，书籍列表会显示我当前的阅读进度(0%~100%)。当我再次点击之前的图书详情，进入后自动跳转到之前阅读的上下文。
状态：✅ 已完成

## 实现细节

### 后端实现
1. **数据库表** (`src-tauri/src/db.rs:76-86`)
   - `reading_progress` 表存储阅读进度
   - 字段：book_id, chapter_index, scroll_offset, updated_at
   - UNIQUE(book_id) 约束确保每本书只有一条进度记录

2. **API接口** (`src-tauri/src/lib.rs`)
   - `save_reading_progress` (line 2167): 保存阅读进度（章节索引和滚动位置）
   - `get_reading_progress` (line 2188): 获取指定书籍的阅读进度
   - 已在 invoke_handler 中注册 (line 2283-2284)

### 前端实现

#### 1. 进度保存 (`ImmersiveReader.tsx`)

**保存时机**（改进后的方案）：
- ✅ **返回图书馆时保存** (line 296-323)
  - 用户点击"返回图书馆"按钮时
  - 保存当前章节索引和滚动位置

- ✅ **切换章节时保存** (line 326-348)
  - 用户切换到其他章节前
  - 保存当前章节的阅读位置

**为什么不使用滚动监听**：
- ❌ 滚动事件会导致组件频繁重新渲染
- ❌ 防抖机制不够可靠
- ✅ 在导航时保存更简单可靠

#### 2. 进度显示 (`ImmersiveReader.tsx:83-134`)
- 在图书馆视图中显示每本书的阅读进度百分比
- 加载书籍列表时，为每本书：
  - 调用 `get_book_details` 获取章节总数
  - 调用 `get_reading_progress` 获取当前阅读位置
  - 计算进度：`((chapter_index + 1) / total_chapters) * 100`
- 返回图书馆时自动刷新进度显示

#### 3. 进度恢复 (`ImmersiveReader.tsx:221-310`)
- 打开书籍时自动加载保存的阅读进度 (line 224-233)
- 跳转到上次阅读的章节 (line 246)
- **精确恢复滚动位置** (line 264-278, 294-308)
  - 使用 `window.scrollTo()` 恢复到上次的 `scroll_offset`
  - 延迟300ms确保内容已渲染
  - 平滑滚动到目标位置
  - 验证滚动是否成功（500ms后检查）
- 详细测试指南：`docs/test_scroll_restoration.md`

#### 4. UI展示 (`BookCard.tsx:63-85`)
- 显示进度百分比文字（如 "45% Read"）
- 显示进度条可视化

## 测试步骤

### 1. 测试进度保存

1. 启动应用：`pnpm tauri dev`
2. 导入一本书籍（EPUB/PDF/TXT/Markdown）
3. 点击书籍卡片进入阅读界面
4. 阅读几个章节
5. **点击"返回图书馆"按钮**
6. 查看控制台日志：
   ```
   💾 返回图书馆前保存进度: { bookId: X, chapterIndex: Y, scrollOffset: Z }
   ✅ 阅读进度保存成功
   ```

### 2. 测试进度显示

1. 返回图书馆后，观察书籍卡片
2. 应该显示进度百分比（如 "10% Read"）
3. 进度条应该有相应的填充
4. 查看控制台日志：
   ```
   📚 加载书籍列表: 1 本书
   📖 书籍 "..." 章节数: 62
   📍 书籍 "..." 阅读进度: { chapter_index: 0, scroll_offset: 100 }
   📊 书籍 "..." 进度百分比: 2 %
   ```

### 3. 测试进度恢复

1. 在图书馆中点击之前阅读过的书籍
2. 预期：自动跳转到上次阅读的章节
3. 页面应该滚动到上次的位置

### 4. 测试切换章节保存

1. 在阅读界面切换到不同章节
2. 查看控制台日志：
   ```
   💾 切换章节前保存进度: { bookId: X, chapterIndex: Y, scrollOffset: Z }
   ✅ 阅读进度保存成功
   ```

## 已修复的问题

### 问题1：API名称错误
- **问题**：使用了不存在的 `get_book_chapters` API
- **修复**：改为使用 `get_book_details` API (line 95)

### 问题2：进度计算不准确
- **问题**：使用 `chapter_index / total_chapters` 导致第一章显示0%
- **修复**：改为 `(chapter_index + 1) / total_chapters` (line 112)
  - 第0章（第一章）：(0+1)/10 = 10%
  - 第5章：(5+1)/10 = 60%
  - 第9章（最后一章）：(9+1)/10 = 100%

### 问题3：滚动监听导致组件频繁重渲染
- **问题**：使用 `window.addEventListener('scroll')` 导致：
  - 组件频繁重新渲染
  - 滚动监听器被反复添加和移除
  - 防抖机制不可靠
- **修复**：改为在导航时保存进度
  - 返回图书馆时保存
  - 切换章节时保存
  - 更简单、更可靠

### 问题4：滚动位置始终为0（关键问题）
- **问题**：
  - 使用 `window.scrollY` 获取滚动位置
  - 但实际滚动容器是 ReaderContent 组件内的 `<section>` 元素
  - 导致 `scrollOffset` 始终为 0，无法精确恢复阅读位置
- **修复**：使用 React ref 访问实际滚动容器
  - 在 ReaderContent 中使用 `forwardRef` 和 `useImperativeHandle`
  - 暴露 `getScrollPosition()` 和 `setScrollPosition()` 方法
  - 父组件通过 ref 调用这些方法获取和设置滚动位置
  - 代码位置：
    - `ReaderContent.tsx:10-13` - 接口定义
    - `ReaderContent.tsx:60-93` - forwardRef 实现
    - `ReaderContent.tsx:499` - scrollContainerRef 绑定
    - `ImmersiveReader.tsx:44` - readerContentRef 创建
    - `ImmersiveReader.tsx:320, 352` - 获取滚动位置
    - `ImmersiveReader.tsx:268, 298` - 设置滚动位置

## 技术要点

1. **保存时机优化**：在用户导航时保存，而不是滚动时
2. **异步加载**：使用 `Promise.all` 并行加载所有书籍的进度
3. **错误处理**：每本书的进度加载失败不影响其他书籍
4. **数据库约束**：UNIQUE(book_id) 确保使用 INSERT OR REPLACE 更新进度
5. **进度计算**：使用 `(chapter_index + 1) / total_chapters` 确保第一章显示进度

## 进度计算示例

假设一本书有 62 章：

| 当前章节 | chapter_index | 计算公式 | 进度 |
|---------|--------------|---------|------|
| 第1章   | 0            | (0+1)/62 | 2%   |
| 第10章  | 9            | (9+1)/62 | 16%  |
| 第31章  | 30           | (30+1)/62| 50%  |
| 第62章  | 61           | (61+1)/62| 100% |

任务：隐藏AI助手模块

流程：帮我把笔记详情最下方的AI助手模块隐藏掉，把AI助手的llm api key设置功能挪出来，放到首页的header中，作为全局设置模块中的一个tab。

状态：✅ 已完成

## 实现细节

### 前端实现

#### 1. 隐藏 NoteDetailPanel 中的 AI 助手模块 (`src/components/notes/NoteDetailPanel.tsx`)
- 移除了整个 AI 助手面板（包括文字释义、章节对话功能）
- 移除了相关的状态变量：`isAIAssistantOpen`, `isAIConfigOpen`, `aiLoading`, `aiMode`, `explainResult`, `chatMessages`, `chatInput`
- 移除了相关的函数：`handleSendChatMessage`, AI 释义触发逻辑
- 移除了 `AIConfigDialog` 的导入和使用
- 更新了空状态提示文字，移除了"或直接使用下方的 AI 助手"

#### 2. 创建全局设置对话框组件 (`src/components/common/GlobalSettingsDialog.tsx`)
- 新建了 `GlobalSettingsDialog` 组件
- 支持多个 tab：AI 助手配置、通用设置（预留）
- AI 配置 tab 中包含打开 AI 配置的按钮，点击后打开 `AIConfigDialog`
- 支持深色/浅色主题
- 使用模态对话框形式展示

#### 3. 在 ImmersiveReader 的 header 中添加全局设置按钮 (`src/components/immersive-reader/ImmersiveReader.tsx`)
- 在所有视图的 header 中添加了设置按钮（齿轮图标）
  - 图书馆视图 (Library View)
  - 数据分析视图 (Analytics View)
  - 阅读视图 (Reading View)
- 添加了 `isGlobalSettingsOpen` 状态来控制设置对话框的显示
- 在每个视图的末尾添加了 `GlobalSettingsDialog` 组件
- 设置按钮位于 header 右侧，导入图书按钮旁边

## 测试步骤

### 1. 测试 NoteDetailPanel 中 AI 助手已隐藏
1. 启动应用：`pnpm tauri dev`
2. 打开一本书进入阅读界面
3. 创建或选择一个笔记
4. 确认笔记详情面板底部不再显示 AI 助手模块

### 2. 测试全局设置按钮
1. 在图书馆视图，点击 header 右上角的齿轮图标
2. 确认弹出全局设置对话框
3. 确认有"AI 助手配置"和"通用设置"两个 tab
4. 切换到"AI 助手配置" tab
5. 点击"打开 AI 配置"按钮
6. 确认弹出 AI 配置对话框，可以配置 API Key 等参数

### 3. 测试所有视图的设置按钮
1. 在图书馆视图测试设置按钮
2. 切换到数据分析视图，测试设置按钮
3. 打开一本书进入阅读视图，测试设置按钮
4. 确认所有视图的设置按钮都能正常打开全局设置对话框

### 4. 测试主题适配
1. 切换到深色模式
2. 打开全局设置对话框
3. 确认对话框的颜色和样式适配深色主题
4. 切换回浅色模式，确认样式正常

## 技术要点

1. **组件解耦**：将 AI 配置从笔记详情面板中分离，提升为全局设置
2. **状态管理**：在 ImmersiveReader 中统一管理全局设置对话框的状态
3. **主题适配**：GlobalSettingsDialog 支持深色/浅色主题，与应用整体风格一致
4. **用户体验**：设置按钮在所有视图中都可访问，方便用户随时配置 AI 功能

任务：改变AI释义交互组件

流程：原来的AI释义输出的内容会在AI助手模块显示，但是现在AI助手模块被移除了，我的想法是，当有人点击AI释义，会在当前文本下方弹出小卡片，然后在小卡片里输出内容。小卡片可以自行关闭。

状态：✅ 已完成

## 实现细节

### 前端实现

#### 1. 创建 AI 释义小卡片组件 (`src/components/reader/AIExplainCard.tsx`)
- 新建了 `AIExplainCard` 组件
- 功能特性：
  - 自动调用 `explain_text` API 获取释义结果
  - 显示选中的文本（带引用样式）
  - 显示加载状态（带动画）
  - 显示错误状态
  - 显示释义结果
  - 可关闭按钮
- 智能定位：
  - 在选中文本下方 10px 显示
  - 自动避免超出视口边界
  - 如果下方空间不足，自动显示在上方
- 支持深色/浅色主题

#### 2. 在 ReaderContent 中集成 AI 释义小卡片 (`src/components/immersive-reader/ReaderContent.tsx`)
- 添加了 AI 释义卡片的状态管理：
  - `showAIExplainCard`: 控制卡片显示/隐藏
  - `aiExplainText`: 存储选中的文本
  - `aiExplainPosition`: 存储卡片显示位置
- 修改 `handleExplainText` 函数：
  - 不再调用父组件的回调
  - 直接显示 AI 释义小卡片
  - 保存选中文本和位置信息
- 在组件末尾渲染 `AIExplainCard`

## 测试步骤

### 1. 测试 AI 释义小卡片
1. 启动应用：`pnpm tauri dev`
2. 打开一本书进入阅读界面
3. 选中一段文字
4. 点击工具栏中的 AI 释义按钮（紫色星星图标）
5. 确认在选中文本下方弹出小卡片
6. 确认卡片显示：
   - 选中的文本（带引用样式）
   - 加载动画
   - AI 释义结果
7. 点击关闭按钮，确认卡片消失

### 2. 测试卡片定位
1. 在页面顶部选中文字，确认卡片显示在下方
2. 在页面底部选中文字，确认卡片显示在上方
3. 在页面左侧选中文字，确认卡片不超出左边界
4. 在页面右侧选中文字，确认卡片不超出右边界

### 3. 测试主题适配
1. 切换到深色模式
2. 选中文字并点击 AI 释义
3. 确认卡片的颜色和样式适配深色主题
4. 切换回浅色模式，确认样式正常

## 技术要点

1. **组件解耦**：AI 释义功能独立为单独的卡片组件
2. **智能定位**：自动计算卡片位置，避免超出视口
3. **状态管理**：在 ReaderContent 中管理卡片的显示状态
4. **用户体验**：卡片显示在选中文本附近，方便阅读

任务：改进 AI 释义错误处理

流程：在进行 AI 释义时，如果配置的 LLM API 有问题，直接提示错误信息，不要一直卡住。

状态：✅ 已完成

## 实现细节

### 后端实现

#### 1. 添加 HTTP 请求超时配置 (`src-tauri/src/lib.rs:258-262`)
- 创建带超时的 HTTP 客户端
- 连接超时：10 秒
- 总请求超时：30 秒
- 使用 `reqwest::Client::builder()` 配置超时参数

#### 2. 创建错误处理辅助函数 (`src-tauri/src/lib.rs:250-261`)
- `handle_request_error()` 函数统一处理 HTTP 请求错误
- 区分不同类型的错误：
  - **超时错误** (`is_timeout()`): "请求超时：API 响应时间过长（超过30秒），请检查网络连接或稍后重试"
  - **连接错误** (`is_connect()`): "连接失败：无法连接到 API 服务器，请检查网络连接和 Base URL 配置"
  - **请求错误** (`is_request()`): "请求错误：请求格式有误，请检查 API 配置"
  - **其他错误**: 显示原始错误信息

#### 3. 改进 API 错误响应处理
- 所有平台（OpenAI、Anthropic、Google）统一使用 `handle_request_error()`
- API 错误响应包含 HTTP 状态码和详细错误信息
- 错误消息格式：`"API 错误 (状态码): 详细信息。请检查 API Key 和配置是否正确"`

#### 4. 应用到所有 LLM API 调用
- `call_llm_api()` 函数中的所有平台分支都应用了新的错误处理
- OpenAI 平台：2 处（chat completions）
- Anthropic 平台：2 处（messages API）
- Google 平台：2 处（generateContent API）

## 测试步骤

### 1. 测试超时错误
1. 配置一个响应缓慢的 API 端点（或使用网络限速工具）
2. 选中文本并点击 AI 释义
3. 等待 30 秒
4. 确认显示超时错误提示：
   ```
   请求超时：API 响应时间过长（超过30秒），请检查网络连接或稍后重试
   ```

### 2. 测试连接错误
1. 配置一个无效的 Base URL（如 `https://invalid-api-endpoint.com`）
2. 选中文本并点击 AI 释义
3. 确认显示连接错误提示：
   ```
   连接失败：无法连接到 API 服务器，请检查网络连接和 Base URL 配置
   ```

### 3. 测试 API Key 错误
1. 配置一个无效的 API Key
2. 选中文本并点击 AI 释义
3. 确认显示 API 错误提示（包含状态码 401）：
   ```
   API 错误 (401 Unauthorized): Invalid API key。请检查 API Key 和配置是否正确
   ```

### 4. 测试正常情况
1. 配置正确的 API Key 和 Base URL
2. 选中文本并点击 AI 释义
3. 确认正常显示 AI 释义结果

## 技术要点

1. **超时配置**：使用 `reqwest::Client::builder()` 配置超时参数
2. **错误分类**：使用 `reqwest::Error` 的方法区分不同类型的错误
3. **用户友好**：错误消息清晰明确，提供具体的解决建议
4. **统一处理**：所有平台使用相同的错误处理逻辑，保持一致性

## 用户体验改进

- ✅ **不再卡住**：30 秒超时确保不会无限等待
- ✅ **快速失败**：10 秒连接超时快速检测网络问题
- ✅ **明确提示**：错误消息清晰说明问题原因和解决方法
- ✅ **状态码显示**：API 错误包含 HTTP 状态码，便于调试



流程：当前的情况时按f11会进入全屏模式，我想把全屏模式升级为阅读模式，主要就是把两侧的笔记列表和笔记详情区域隐藏起来，还有最上方的heard区域也要隐藏起来，只保留阅读区的内容。当开启阅读模式时，提示已进入阅读模式，可按f11退出，当选中阅读区文本时，工具栏只有AI释义功能。

状态：✅ 已完成

## 实现细节

### 前端实现

#### 1. 添加阅读模式状态 (`src/components/immersive-reader/ImmersiveReader.tsx`)
- 添加 `isReadingMode` 状态来控制阅读模式
- 添加 F11 键监听：
  - 只在阅读视图中响应 F11 键
  - 切换阅读模式状态
  - 显示提示消息（进入/退出阅读模式）

#### 2. 修改阅读视图布局
- **Header 区域**：
  - 在阅读模式下完全隐藏
  - 使用条件渲染 `{!isReadingMode && <header>...</header>}`
- **左侧笔记侧边栏**：
  - 在阅读模式下隐藏
  - 使用条件渲染包裹
- **阅读内容区域结构调整**：
  - ✅ **重构为包含章节列表和内容的容器**
  - 正常模式：`w-3/5`（60% 宽度）
  - 阅读模式：外层容器 `w-full flex justify-center`（100% 宽度，居中对齐）
  - 阅读模式：内层容器 `w-3/5`（60% 宽度，保持与常态模式一致）
  - 添加 `position: relative` 作为章节列表的定位参考
- **章节列表**：
  - ✅ **在阅读模式下保留显示**（悬停展开）
  - ✅ **相对于阅读区定位**：使用 `absolute` 定位，相对于阅读内容区域
  - 位置：`left-0`（阅读区左侧，而非屏幕左侧）
  - 悬停触发按钮也相对于阅读区左边缘
- **阅读内容**：
  - 使用 `flex-1` 占据剩余空间
  - ✅ **滚动条在阅读区右侧**：因为滚动容器是 ReaderContent 内部的 section 元素
  - ✅ **添加自定义滚动条样式**，确保滚动条始终可见
  - 使用 `overflow-y-scroll` 替代 `overflow-y-auto`
  - 自定义滚动条颜色适配深色/浅色主题
- **右侧笔记详情面板**：
  - 在阅读模式下隐藏
  - 使用条件渲染包裹

#### 3. 修改工具栏显示 (`src/components/immersive-reader/ReaderContent.tsx`)
- 添加 `isReadingMode` prop
- 在工具栏中根据 `isReadingMode` 显示不同的按钮：
  - **阅读模式**：只显示 AI 释义和取消按钮
  - **正常模式**：显示所有按钮（高亮、下划线、AI 释义、创建笔记、取消）

## 测试步骤

### 1. 测试进入阅读模式
1. 启动应用：`pnpm tauri dev`
2. 打开一本书进入阅读界面
3. 按 F11 键
4. 确认显示提示："已进入阅读模式，按 F11 退出"
5. 确认界面变化：
   - Header 消失
   - 左侧笔记侧边栏消失
   - ✅ **章节列表保留**（鼠标悬停在左边缘可展开）
   - 右侧笔记详情面板消失
   - 阅读内容占满整个屏幕
   - ✅ **滚动条可见**（右侧显示自定义样式的滚动条）

### 2. 测试阅读模式下的工具栏
1. 在阅读模式下选中一段文字
2. 确认工具栏只显示：
   - AI 释义按钮（紫色星星）
   - 取消按钮（X）
3. 确认不显示：
   - 高亮按钮
   - 下划线按钮
   - 创建笔记按钮

### 3. 测试退出阅读模式
1. 在阅读模式下再次按 F11 键
2. 确认显示提示："已退出阅读模式"
3. 确认界面恢复：
   - Header 显示
   - 左侧笔记侧边栏显示
   - 章节列表显示（位置恢复到笔记侧边栏右侧）
   - 右侧笔记详情面板显示
   - 阅读内容恢复为 60% 宽度

### 4. 测试章节列表功能
1. 在阅读模式下，将鼠标移到屏幕最左侧
2. 确认章节列表从左侧滑出
3. 点击不同章节，确认可以正常切换
4. 鼠标移开，确认章节列表自动收起

### 5. 测试滚动条
1. 在阅读模式下滚动页面
2. 确认右侧滚动条可见且样式美观
3. 切换深色/浅色主题，确认滚动条颜色适配主题

### 6. 测试 AI 释义功能
1. 在阅读模式下选中文字
2. 点击 AI 释义按钮
3. 确认 AI 释义小卡片正常显示
4. 确认卡片可以正常关闭

### 7. 测试主题适配
1. 切换到深色模式
2. 进入阅读模式
3. 确认阅读内容的背景色和文字颜色正常
4. 确认滚动条颜色适配深色主题
5. 切换回浅色模式，确认样式正常

## 技术要点

1. **键盘事件监听**：使用 `useEffect` 监听 F11 键，只在阅读视图中响应
2. **条件渲染**：使用 `{!isReadingMode && ...}` 来隐藏不需要的元素
3. **响应式布局**：阅读内容区域根据模式动态调整宽度
4. **用户反馈**：使用 Toast 提示用户当前状态
5. **工具栏简化**：在阅读模式下只保留核心功能（AI 释义）
6. ✅ **章节列表和滚动条相对定位**：
   - 重构阅读区域为双层容器结构
   - 外层容器：常态模式 `w-3/5`，阅读模式 `w-full flex justify-center`
   - 内层容器：常态模式 `w-full`，阅读模式 `w-3/5`（保持一致宽度）
   - 章节列表使用 `absolute` 定位，相对于内层容器（而非屏幕）
   - 滚动条在 ReaderContent 内部，自然位于阅读区右侧
   - 阅读模式下，内容区域居中显示，章节列表和滚动条位置与常态模式保持一致
   - 确保章节列表和滚动条都在阅读区域内，紧贴阅读区边缘（就近原则）
7. ✅ **自定义滚动条**：
   - 使用 `overflow-y-scroll` 确保滚动条始终显示
   - WebKit 浏览器：自定义 `::-webkit-scrollbar` 样式
   - Firefox：使用 `scrollbar-width` 和 `scrollbar-color`
   - 滚动条颜色适配深色/浅色主题

## 用户体验改进

- 阅读模式提供沉浸式阅读体验，减少干扰
- F11 键快速切换，操作便捷
- ✅ **保留章节导航**：在阅读模式下仍可通过悬停展开章节列表，方便快速跳转
- 保留 AI 释义功能，方便查询生词和理解难点
- 阅读内容占满屏幕，提升阅读舒适度
- ✅ **滚动条始终可见**：方便用户了解当前阅读位置和剩余内容